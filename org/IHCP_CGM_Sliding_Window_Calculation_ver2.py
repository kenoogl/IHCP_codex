# -*- coding: utf-8 -*-
"""
Created on Tue Aug 19 20:18:01 2025

@author: SHI ZHENGQI

Final Version of Inverse Heat Conduction Problem by using The Conjugate Gradient Mtehod: CGM

-1- Read Matlab Files whitch were generated by the IR Camera in matlab format
-2- Poly Fit the Thermal Properties (heat conductivity & specific heat)
-3- Direct Solver for heat transfer equation
-4- Adjoint Solver for CGM
-5- surface heat flux inverse calculation for a single calculation window
-6- surface heat flux inverse calculation for the whole time domain 

"""

import re
import os
import time
from math import sin, radians

import numpy as np
import pandas as pd

from numba import njit, prange
from scipy.io import loadmat

from scipy.sparse.linalg import LinearOperator,cg
from scipy.sparse import diags

# === Reading and Poly-Fitting Thermal Properties for SUS304 === #
Thermal_properties_file_path = "metal_thermal_properties.csv"
# Thermal_properties_file_path = "D:/HT_Calculation_Python\\thermal_properties_SUS304\\metal_thermal_properties.csv"
# Thermal_properties_file_path = "C:/HT_Calculation_Python\\thermal_properties_SUS304\\metal_thermal_properties.csv"
sus304_data = pd.read_csv(Thermal_properties_file_path)

sus304_temp = sus304_data['Temperature/K'].values
sus304_rho = sus304_data['Density'].values
sus304_cp = sus304_data['Specific_Heat'].values
sus304_k = sus304_data['Thermal_Conductivity'].values

# Getting the 3-rd Poly Fiiting Factors for Density/Specific Heat/Thermal Conductivity
rho_coeffs = np.polyfit(sus304_temp, sus304_rho, 3)
cp_coeffs = np.polyfit(sus304_temp, sus304_cp, 3)
k_coeffs  = np.polyfit(sus304_temp, sus304_k,  3)
# Result = [a,b,c,d] for y = ax^3 + bx^2 + cx + d

# Poly-fit Result Calculation Unit / Return result = ax^3 + bx^2 + cx + d
@njit
def polyval_numba(coeffs, x):
    result = 0.0
    for i in range(len(coeffs)):
        result += coeffs[i] * x ** (len(coeffs) - i - 1)
    return result

@njit(parallel = True)
def thermal_properties_calculator(Temperature, cp_coeffs, k_coeffs):
    
    ni, nj, nk = Temperature.shape
    cp = np.empty((ni, nj, nk))
    k = np.empty((ni, nj, nk))

    for i in prange(ni):
        for j in range(nj):
            for k_ijk in range(nk):
                
                T_current = Temperature[i, j, k_ijk]
                cp[i, j, k_ijk] = polyval_numba(cp_coeffs, T_current)
                k[i, j, k_ijk] = polyval_numba(k_coeffs, T_current)
                
    return cp, k

rho = polyval_numba(rho_coeffs, 225 + 273.15)


'''
Define the Function to Find the Files whitch can Match Name format["SUS" + number + ".MAT"]
Sort the Files by the Keys of Extract Numbers from the Small to Large
'''

def extract_sorted_mat_files(folder_path):
    def extract_number(file_name):
        match = re.match(r'SUS(\d+)\.MAT', file_name)
        return int(match.group(1)) if match else -1
    
    files = []
    for f in os.listdir(folder_path):
        if f.startswith('SUS') and f.endswith('.MAT'):
            files.append(f)
    return sorted(files, key = extract_number)

'''
Load the Temperature Variation Array of a Specific Region from IR Temperature File
Region: (i_start, j_start) to (i_end, j_end)
'''
def load_region_temperature(folder_path, i_range, j_range):
    i_start, i_end = i_range
    j_start, j_end = j_range

    mat_files = extract_sorted_mat_files(folder_path)
    num_frames = len(mat_files)
    
    height = i_end - i_start + 1
    width = j_end - j_start + 1

    region_data_K = np.zeros((height, width, num_frames))
    
    # read temperature array of a specific location from IR camera matlac files,
    # preserve the temperature data to region_data_K & region_data_C

    for idx, file in enumerate(mat_files):
        
        mat_data = loadmat(os.path.join(folder_path, file))
        frame_data = mat_data[file[:-4]]
        
        sub_region = frame_data[i_start:i_end + 1, j_start:j_end + 1]
        region_data_K[:, :, idx] = sub_region

    return region_data_K, num_frames

'''
Define the Physical properties of Calculation Region 
'''
nz = 20                                                                        # grid numbers at x, y, z direction
dx, dy = 0.12e-3, (0.12e-3 * sin(radians(80)) / sin(radians(45)))              # real x_direction & y_direction length for a single pixel 
Lz = 0.5e-3                                                                    # real x, y, z direction length
 
stretch_factor = 3   
# Grid faces plotting for Z direction
z_faces = np.linspace(1, 0, nz + 1)                                                            # Generate nz+1 grid surfaces for nz grids

# Irregular grid generation from regular grid faces
z_faces = Lz - (Lz / (np.exp(stretch_factor) - 1)) * (np.exp(stretch_factor * z_faces) - 1)    # Generate stretched grid 

z_centers = np.zeros(nz)                                  # Center coordinates for nz grids

z_centers[0] = z_faces[0]                                 # The Bottom-most grid center coordinate(half CV/ grid center point overlaps the Bottom-most boundary)
z_centers[-1] = z_faces[-1]                               # The top-most grid center coordinate(half CV/ grid center point overlaps the top-most boundary)
z_centers[1:-1] = (z_faces[1:-2] + z_faces[2:-1]) / 2     # Intermediate grids
                
# Boundary component Calculation
dz = np.diff(z_faces)                                # Calculate every-grid size

dz_t = np.zeros(nz)                                  # Top component_delta_z_t
dz_t[-1] = np.inf                                    # Top component_delta_z_t for top-most CV
dz_t[:-1] = z_centers[1:] - z_centers[:-1]           # Other Top component_delta_z_t

dz_b = np.zeros(nz)                                  # Bottom component_delta_z_b
dz_b[0] = np.inf                                     # Bottom component_delta_z_b for Bottom-most CV
dz_b[1:] = z_centers[1:] - z_centers[:-1]            # Other Bottom component_delta_z_b

# debug
print("z_faces : ", z_faces)
print("z_centers : ", z_centers)
print("dz : ", dz)
print("dz_t : ", dz_t)
print("dz_b : ", dz_b)
#

'''
=== Direct problem solver  ===
=== Sensitivity problem solver ===

coefficients(a*) for A whitch used csr_matrix (Compressed Sparse Row matrix: CSR) class
and right hand side (b) building for direct heat conduction problems for 1 time step (Ax = b)
'''
@njit(parallel=True, fastmath=False)
def coeffs_and_rhs_building_DHCP(T_initial, q_surface, rho, cp, k, dx, dy, dz, dz_b, dz_t, dt):
    ni, nj, nk = T_initial.shape
    N = ni * nj * nk
    
    a_w = np.zeros(N)
    a_e = np.zeros(N)
    a_s = np.zeros(N)
    a_n = np.zeros(N)
    a_b = np.zeros(N)
    a_t = np.zeros(N)
    a_p = np.zeros(N)
    
    b   = np.zeros(N)
    
    for p in prange(N):
        i = p % ni
        j = (p // ni) % nj
        k_ijk = p // (ni * nj)
        
        dz_k = dz[k_ijk]
        dz_t_k = dz_t[k_ijk]
        dz_b_k = dz_b[k_ijk]
        
        k_p = k[i, j, k_ijk]
        
        a_p_0 = rho * cp[i, j, k_ijk] * dx * dy * dz_k / dt
        
        a_w[p] = 0.0 if j == 0                 else (2 * k_p * k[i, j-1, k_ijk] / (k_p + k[i, j-1, k_ijk])) * dy * dz_k / dx
        a_e[p] = 0.0 if j == nj-1              else (2 * k_p * k[i, j+1, k_ijk] / (k_p + k[i, j+1, k_ijk])) * dy * dz_k / dx
        a_s[p] = 0.0 if i == 0                 else (2 * k_p * k[i-1, j, k_ijk] / (k_p + k[i-1, j, k_ijk])) * dx * dz_k / dy
        a_n[p] = 0.0 if i == ni-1              else (2 * k_p * k[i+1, j, k_ijk] / (k_p + k[i+1, j, k_ijk])) * dx * dz_k / dy
        a_b[p] = 0.0 if k_ijk == 0             else (2 * k_p * k[i, j, k_ijk-1] / (k_p + k[i, j, k_ijk-1])) * dx * dy / dz_b_k
        a_t[p] = 0.0 if k_ijk == nk-1          else (2 * k_p * k[i, j, k_ijk+1] / (k_p + k[i, j, k_ijk+1])) * dx * dy / dz_t_k
        
        a_p[p] = a_w[p] + a_e[p] + a_s[p] + a_n[p] + a_b[p] + a_t[p] + a_p_0
        
        rhs = a_p_0 * T_initial[i, j, k_ijk]
        
        if k_ijk == nk - 1:
            rhs += q_surface[i, j] * dx * dy
        b[p] = rhs
        
    return a_w, a_e, a_s, a_n, a_b, a_t, a_p, b

def assemble_A_DHCP(ni, nj, nk, a_w, a_e, a_s, a_n, a_b, a_t, a_p):
    N = ni * nj * nk
    
    off_i = 1           # offsets for i direction (south & north)
    off_j = ni          # offsets for j direction (west & east)
    off_k = ni * nj     # offsets for k direction (bottom & top)

    D0   = a_p.copy()                 # len N
    D_im1 = -a_s[off_i: ]        # len N-1
    D_jm1 = -a_w[off_j: ]        # len N-ni
    D_km1 = -a_b[off_k: ]        # len N-ni*nj
    
    D_ip1 = -a_n[ :N-off_i]         # len N-1
    D_jp1 = -a_e[ :N-off_j]         # len N-ni
    D_kp1 = -a_t[ :N-off_k]         # len N-ni*nj

    A_csr = diags(
        diagonals=[D0, D_im1, D_jm1, D_km1, D_kp1, D_jp1, D_ip1],
        offsets=[0, -off_i, -off_j, -off_k, off_k, off_j, off_i],
        shape=(N, N), format="csr"
    )
    
    return A_csr


def multiple_time_step_solver_DHCP(T_initial, q_surface, nt, rho, cp_coeffs, k_coeffs,
                                       dx, dy, dz, dz_b, dz_t, dt, rtol, maxiter):
    '''
    nt: time step number for Temperature measurement (T_measure)
    T_initial.shape = (ni, nj, nk)
    q_surface:  | heat flux on upper surface
                | shape = (nt-1, ni, nj)
    T_all: 3D Temperature distributation at every time step
    
    return: T_all.shape = (nt, ni, nj, nk)
    '''
    
    ni, nj, nk = T_initial.shape
    T_all = np.empty((nt, ni, nj, nk))
    T_all[0] = T_initial
    
    x0 = T_initial.ravel(order = "F").copy()
    
    for t in range(1, nt):
        
        cp, k = thermal_properties_calculator(T_all[t-1], cp_coeffs, k_coeffs)
        
        a_w, a_e, a_s, a_n, a_b, a_t, a_p, b = coeffs_and_rhs_building_DHCP(T_all[t-1], q_surface[t-1], rho, cp, k, dx, dy, dz, dz_b, dz_t, dt)
        
        A_csr = assemble_A_DHCP(ni, nj, nk, a_w, a_e, a_s, a_n, a_b, a_t, a_p)

        diag = A_csr.diagonal()
        inv_diag = np.where(diag != 0.0, 1.0/diag, 0.0)  # 防除零
        
        def Mv(z):
            return inv_diag * z
        
        M = LinearOperator(A_csr.shape, matvec = Mv)
        
        x, info = cg(A_csr, b, M = M, rtol = rtol, maxiter = maxiter, x0 = x0)
        
        if info > 0:
            print(f"[warn][t={t}] Krylov 未收敛 (info={info})")
        elif info < 0:
            print(f"[error][t={t}] Krylov 非法输入 (info={info})")
        
        # 写入与热启动
        T_all[t] = x.reshape((ni, nj, nk), order="F")
        x0 = x

        
    return T_all
    
'''
=== Adjoint problem solver  ===

coefficients(a*) for A whitch used csr_matrix (Compressed Sparse Row matrix: CSR) class
and right hand side (b) building for adjoint problem for all time step (Ax = b)
'''
@njit(parallel=True, fastmath=False)
def coeffs_and_rhs_building_Adjoint(lambda_initial, T_cal, Y_obs, rho, cp, k, dx, dy, dz, dz_b, dz_t, dt):
    ni, nj, nk = lambda_initial.shape
    N = ni * nj * nk
    
    a_w = np.zeros(N)
    a_e = np.zeros(N)
    a_s = np.zeros(N)
    a_n = np.zeros(N)
    a_b = np.zeros(N)
    a_t = np.zeros(N)
    a_p = np.zeros(N)
    
    b   = np.zeros(N)
    
    for p in prange(N):
        i = p % ni
        j = (p // ni) % nj
        k_ijk = p // (ni * nj)
        
        dz_k = dz[k_ijk]
        dz_t_k = dz_t[k_ijk]
        dz_b_k = dz_b[k_ijk]
        
        k_p = k[i, j, k_ijk]
        
        a_p_0 = rho * cp[i, j, k_ijk] * dx * dy * dz_k / dt
        
        a_w[p] = 0.0 if j == 0                 else (2 * k_p * k[i, j-1, k_ijk] / (k_p + k[i, j-1, k_ijk])) * dy * dz_k / dx
        a_e[p] = 0.0 if j == nj-1              else (2 * k_p * k[i, j+1, k_ijk] / (k_p + k[i, j+1, k_ijk])) * dy * dz_k / dx
        a_s[p] = 0.0 if i == 0                 else (2 * k_p * k[i-1, j, k_ijk] / (k_p + k[i-1, j, k_ijk])) * dx * dz_k / dy
        a_n[p] = 0.0 if i == ni-1              else (2 * k_p * k[i+1, j, k_ijk] / (k_p + k[i+1, j, k_ijk])) * dx * dz_k / dy
        a_b[p] = 0.0 if k_ijk == 0             else (2 * k_p * k[i, j, k_ijk-1] / (k_p + k[i, j, k_ijk-1])) * dx * dy / dz_b_k
        a_t[p] = 0.0 if k_ijk == nk-1          else (2 * k_p * k[i, j, k_ijk+1] / (k_p + k[i, j, k_ijk+1])) * dx * dy / dz_t_k
        
        a_p[p] = a_w[p] + a_e[p] + a_s[p] + a_n[p] + a_b[p] + a_t[p] + a_p_0
        
        rhs = a_p_0 * lambda_initial[i, j, k_ijk]
        
        if k_ijk == 0:
            rhs += 2 * (T_cal[i, j] - Y_obs[i, j]) * dx * dy
        b[p] = rhs
        
    return a_w, a_e, a_s, a_n, a_b, a_t, a_p, b

def assemble_A_Adjoint(ni, nj, nk, a_w, a_e, a_s, a_n, a_b, a_t, a_p):
    N = ni * nj * nk
    
    off_i = 1           # offsets for i direction (south & north)
    off_j = ni          # offsets for j direction (west & east)
    off_k = ni * nj     # offsets for k direction (bottom & top)

    D0   = a_p.copy()                 # len N
    D_im1 = -a_s[off_i: ]        # len N-1
    D_jm1 = -a_w[off_j: ]        # len N-ni
    D_km1 = -a_b[off_k: ]        # len N-ni*nj
    
    D_ip1 = -a_n[ :N-off_i]         # len N-1
    D_jp1 = -a_e[ :N-off_j]         # len N-ni
    D_kp1 = -a_t[ :N-off_k]         # len N-ni*nj

    A_csr = diags(
        diagonals=[D0, D_im1, D_jm1, D_km1, D_kp1, D_jp1, D_ip1],
        offsets=[0, -off_i, -off_j, -off_k, off_k, off_j, off_i],
        shape=(N, N), format="csr"
    )
    
    return A_csr


def multiple_time_step_solver_Adjoint(T_cal, Y_obs, nt, rho, cp_coeffs, k_coeffs,
                                       dx, dy, dz, dz_b, dz_t, dt, rtol, maxiter):
    '''
    nt: time step number for Temperature measurement (Y_obs)
    
    T_cal: 3D Temperature distributation at every time step based on DHCP solver
            T_cal.shape = (nt, ni, nj, nk)
            
    Y_obs: 2D Temperature distributation at every time step based on IR camera reading
    
    return: lambda_field.shape = (nt, ni, nj, nk)
    '''
    
    ni, nj, nk = T_cal[0].shape
    lambda_field = np.empty_like(T_cal)
    lambda_field[-1] = 0
    
    lambda_initial = lambda_field[-1]
    
    x0 = lambda_initial.ravel(order = "F").copy()
    
    for t in range(nt-2, -1, -1):
        
        lambda_initial = lambda_field[t+1]
        
        cp, k = thermal_properties_calculator(T_cal[t], cp_coeffs, k_coeffs)
        
        a_w, a_e, a_s, a_n, a_b, a_t, a_p, b = coeffs_and_rhs_building_Adjoint(
            lambda_initial, T_cal[t][:,:,0], Y_obs[t], rho, cp, k, dx, dy, dz, dz_b, dz_t, dt)
        
        A_csr = assemble_A_Adjoint(ni, nj, nk, a_w, a_e, a_s, a_n, a_b, a_t, a_p)

        diag = A_csr.diagonal()
        inv_diag = np.where(diag != 0.0, 1.0/diag, 0.0)  # 防除零
        
        def Mv(z):
            return inv_diag * z
        
        M = LinearOperator(A_csr.shape, matvec = Mv)
        
        x, info = cg(A_csr, b, M = M, rtol = rtol, maxiter = maxiter, x0 = x0)
        
        
        if info > 0:
            print(f"[warn][t={t}] Krylov 未收敛 (info={info})")
        elif info < 0:
            print(f"[error][t={t}] Krylov 非法输入 (info={info})")
        
        # 写入与热启动
        lambda_field[t] = x.reshape((ni, nj, nk), order="F")
        x0 = x

    return lambda_field

'''
=== CGM for one time window ===
Prediction of the surface heat flux by using the Conjugate gradient method: CGM
'''

def global_CGM_time(T_init, Y_obs, q_init, dx, dy, dz, dz_b, dz_t, dt, 
                        rho, cp_coeffs, k_coeffs, CGM_iteration = 20000
                        ):
    
    nt = Y_obs.shape[0]                             # Y_obs shape(nt, ni, nj) Observation Temperature array for whole time domain
    ni, nj, nk = T_init.shape                       # T_init shape(ni, nj, nk) Initial temperature distribution
    q = q_init.copy()                               # (nt-1, ni, nj) Initial surface heat flux guess
    
    J_hist = []                                     # J_list J saving for every iteration
    
    M = ni * nj
    sigma = 1.8                                                 # Measurement error assumption
    epsilon = M * (sigma ** 2) * (nt-1)                         # iteration stop criteration
    
    grad = np.zeros_like(q)                         # grad_J_q shape(nt-1, ni, nj) heat flux change gradient for upper surface 
    grad_last = np.zeros_like(q)                    # grad_J_q_last shape(nt-1, ni, nj) heat flux change gradient for upper surface at the last iteration
    
    bottom_idx, top_idx = 0, -1
    # eps = 1e-12
    eps = 0
    dire_reset_every = 5
    
    p_n_last = np.zeros_like(q)
    
    # —— 平台检测参数 —— #
    P = 10                      # 近 P 次平均
    eta = 1e-4                  # 平均相对下降阈值（<0.01%）
    min_iter = 10               # 最小迭代数，防早停

    def _dot(a, b):
        return float(np.tensordot(a, b, axes = a.ndim))
   
    for it in range(CGM_iteration):
        t0 = time.time()
        
        # Step 1: direct problem for all time steps
        T_cal = multiple_time_step_solver_DHCP(
            T_init, q, nt, rho, cp_coeffs, k_coeffs,
            dx, dy, dz, dz_b, dz_t, dt,
            rtol = 1e-6, maxiter = 20000
            )
            
        # Step 2: stopping criterion check
        res_T = T_cal[1:, :, :, bottom_idx] - Y_obs[1:] # shape = (nt-1, ni, nj)
        delta_T = np.abs(res_T)
        J = float(np.tensordot(res_T, res_T, axes = res_T.ndim))
        J_hist.append(J)
        
        # ================== 统一停机判断（Discrepancy & Calculation Bottleneck） ================== #
        # Discrepancy（成功停机）
        if it >= min_iter and J < epsilon and delta_T.max() <= sigma:
            print(f"[STOP] Discrepancy 满足：J={J:.4e} < {epsilon:.4e} 且 max|ΔT|={delta_T.max():.3e} ≤ σ={sigma}")
            break

        # 平台：近 P 次平均相对下降很小（进展到瓶颈）
        rel_drop_avg = None
        if len(J_hist) >= P + 1:
            drops = []
            for i in range(-P, 0):
                prev_i, cur_i = J_hist[i-1], J_hist[i]
                drops.append(max(0.0, (prev_i - cur_i) / (abs(prev_i) + eps)))
            rel_drop_avg = sum(drops) / P

        if it >= min_iter and rel_drop_avg is not None and rel_drop_avg < eta:
            print(f"[STOP] Plateau：rel_drop_avg={rel_drop_avg:.3e} < eta={eta:.1e}（近{P}步平均进展过小）")
            break
        # ================== 统一停机判断结束 ================== #
        
        # Step 3: adjoint problem solution
        lambda_field =  multiple_time_step_solver_Adjoint(
            T_cal, Y_obs, nt, rho, cp_coeffs, k_coeffs,
            dx, dy, dz, dz_b, dz_t, dt,
            rtol = 1e-8, maxiter = 20000
            )       
        if not np.isfinite(lambda_field).all():
            print(f"[WARN] lambda_field 出现 NaN/Inf at iter {it}")
            
        # Step 4: gradient calculation for all time steps       
        for n in range(nt - 1):           
            grad[n] = lambda_field[n][:, :, top_idx]                 # gradient distributation field of the top surface (nt, ni, nj) 
            
        # Step 5: conjugate gradient direction calculation
        if it == 0 or _dot(grad, p_n_last) <= 0 or it % dire_reset_every == 0:
            p_n = grad.copy()
            gamma = 0    
        else:
            y = grad - grad_last
            denom = _dot(grad_last,grad_last) + eps
            gamma = max(0, _dot(grad, y) / denom)
            p_n_candidate = grad + gamma * p_n_last
            
            if _dot(grad, p_n_candidate) > 0:
                p_n = p_n_candidate
                
            else:
                p_n = grad.copy()

        p_n_last = p_n.copy()
        
        # Step 6: set delta_q = p_n on top surface，solve the sensitivity problem
        dT_init = np.zeros_like(T_init) 
        dT = multiple_time_step_solver_DHCP(
                dT_init, p_n, nt, rho, cp_coeffs, k_coeffs,
                dx, dy, dz, dz_b, dz_t, dt,
                rtol = 1e-8, maxiter = 20000
                )
    
        # Step 7: search step size
        Sp = dT[1:, :, :, bottom_idx]
        assert res_T.shape == Sp.shape, (res_T.shape, Sp.shape)
        numerator   = float(np.tensordot(res_T, Sp, axes=res_T.ndim))
        denominator = float(np.tensordot(Sp,  Sp,  axes=Sp.ndim))
        
        beta = numerator / (denominator + eps)
        
        # step size limitation
        beta_max = 1e8

        if it == 0 and abs(beta) > beta_max:
            print(f"  [WARN] beta clipped: {beta:.2e} => {np.sign(beta)*beta_max:.2e}")
            beta = np.clip(beta, -beta_max, beta_max)
        
        # print_interval = 10
        # if it % print_interval == 0 or it == 0 or it == CGM_iteration - 1:
            
        ''' relative desent rate '''    
        rel_drop = None
        if len(J_hist) >= 2:
            rel_drop = abs(J_hist[-1] - J_hist[-2]) / (J_hist[-2])
        
        wall_s = time.time() - t0
        print(f"@ ___ Iter {it:3d} ___ @ wall_s = {wall_s:.3f}s")
        print(f"J = {J:.5e}, beta = {beta:.4e}, rel_drop = {None if rel_drop is None else f'{rel_drop:.3e}'}")
        print(f"|T - Y|: max={delta_T.max():.3e}, min={delta_T.min():.3e}, mean={delta_T.mean():.3e}")
        print(f"grad: min={grad.min():.4e}, max={grad.max():.4e}, mean={grad.mean():.4e}")
        print(f"dT:   min={dT[1:].min():.4e}, max={dT[1:].max():.4e}, mean={dT[1:].mean():.4e}")
        print(f"q:    min={q.min():.4e}, max={q.max():.4e}, mean={q.mean():.4e}") 
        print(f"denominator at iter {it}: {denominator:.4e}")
   
        # 更新q  
        q = q - beta * p_n      
        grad_last = grad.copy()
        
    return q, T_cal[-1], J_hist


def sliding_window_CGM_q_saving(
    Y_obs, T0, dx, dy, dz, dz_b, dz_t, dt, rho, cp_coeffs, k_coeffs,
    window_size, overlap, q_init_value, filename, CGM_iteration=20000
):
    nt = Y_obs.shape[0]
    T_init = T0.copy()
    ni, nj, nk = T_init.shape

    start_idx = 0
    q_total = []
    prev_q_win = None

    safety_counter = 0
    safety_limit = nt * 5  # 经验值

    while start_idx < nt - 1:
        safety_counter += 1
        if safety_counter > safety_limit:
            print("Safety break: too many iterations, check overlap/window settings.")
            break

        # 当前可用窗长
        max_L = min(window_size, (nt - 1) - start_idx)
        end_idx = start_idx + max_L
        Y_obs_win = Y_obs[start_idx: end_idx + 1, :, :]

        # 该窗的初始热流
        if prev_q_win is None:
            q_init_win = np.full((max_L, ni, nj), q_init_value, dtype=float)
        else:
            q_init_win = np.empty((max_L, ni, nj), dtype=float)
            L_overlap = min(overlap, max_L, prev_q_win.shape[0])
            if L_overlap > 0:
                q_init_win[:L_overlap] = prev_q_win[-L_overlap:]
            if L_overlap < max_L:
                edge = prev_q_win[-1]
                q_init_win[L_overlap:] = edge

        start_time_one_window = time.time()
        q_win, T_win_last, J_hist = global_CGM_time(
            T_init, Y_obs_win, q_init_win, dx, dy, dz, dz_b, dz_t, dt,
            rho, cp_coeffs, k_coeffs, CGM_iteration=CGM_iteration
        )
        end_time_one_window = time.time()

        prev_q_win = q_win.copy()

        # 拼接 q（对重叠部分做平均）
        if len(q_total) == 0:
            q_total.append(q_win)
        else:
            overlap_steps = min(overlap, q_win.shape[0], q_total[-1].shape[0])
            if overlap_steps > 0:
                q_total[-1][-overlap_steps:] = 0.5 * q_total[-1][-overlap_steps:] + q_win[:overlap_steps]
                q_total.append(q_win[overlap_steps:])
            else:
                q_total.append(q_win)

        T_init = T_win_last.copy() if T_win_last.ndim == 3 else T_win_last[-1].copy()

        print(f"窗口 {start_idx*dt} - {end_idx*dt} 完成。J = {J_hist[-1]:.3f}, "
              f"时间 = {end_time_one_window - start_time_one_window:.2f}s")

        step = max(1, max_L - overlap)
        start_idx += step

    # 拼接为全局 q，并裁剪到 nt-1
    q_global = np.concatenate(q_total, axis=0)[:nt-1]
    np.save(filename, q_global)
    print(f"已保存q: {filename}, shape={q_global.shape}")
    return q_global


# %%

'''
# === Main Execution  for single calculation window === #

1. Read npy files whitch was processed based on the matlab format files from the IR camera
2. Extract the down side temperature distribution as the initial temperature distribution
3. selection the heat flux calculation domain
4. set a initial heat flux guess
5. surface heat flux calculation for a single calculation window

=== 
'''       
start_All = time.time()

T_measure_K = np.load(r"T_measure_700um_1ms.npy")
# T_measure_K = np.load(r"D:/HT_Calculation_Python/IR_Temperature_data/T_measure_700um_1ms.npy")
# T_measure_K = np.load(r"C:/HT_Calculation_Python/IR_Temperature_data/T_measure_700um_1ms.npy")
dt = 0.001
       
# Extract the temperature distribution of the down side surface and dupilcate the data as the initial temperature distribution
T_measure_init_K = T_measure_K[0, :, :]
T0 = np.repeat(T_measure_init_K[:, :, np.newaxis], nz, axis = 2).astype(np.float64)  # shape: (ny, nx, nz) 
# select the inverse heat transfer problem calculation domain
Y_obs = T_measure_K[:500, :, :]
nt, ni, nj = Y_obs.shape
nk = T0.shape[2]
# initial surface heat flux guess
q_init = np.zeros((nt - 1, ni, nj))

q, T_cal, J_hist = global_CGM_time(T0, Y_obs, q_init, dx, dy, dz, dz_b, dz_t, dt, rho, cp_coeffs, k_coeffs)

# np.save("q_0s_400_frame.npy", q)
# np.save("J_hist_0s_50_frame.npy", J_hist)
# %%
'''
# === Main Execution  for all calculation domain === #
=== 
''' 

# # T_measure_K = np.load(r"D:/HT_Calculation_Python/IR_Temperature_data/T_measure_700um_1ms.npy")
# T_measure_K = np.load(r"C:/HT_Calculation_Python/IR_Temperature_data/T_measure_700um_1ms.npy")

# dt = 0.001
       
# '''提取下表面的初始温度，创建全局初始温度''' 

# T_measure_init_K = T_measure_K[0, :, :]
# T0 = np.repeat(T_measure_init_K[:, :, np.newaxis], nz, axis = 2).astype(np.float64)  # shape: (ny, nx, nz) 

# Y_obs = T_measure_K[:5000, : , : ]

# q_all = sliding_window_CGM_q_saving(Y_obs, T0, dx, dy, dz, dz_b, dz_t, dt, rho, cp_coeffs, k_coeffs,
#                                  window_size = 400, overlap = 20, q_init_value = 0,
#                                  filename = "q_1000fps_0s_5s.npy", CGM_iteration = 20000
#                                 )
end_All = time.time()

print(f"Time for the whole calculation process:{end_All - start_All}")
# %%

'''绘制下表面温度对照图检查是否正确'''




